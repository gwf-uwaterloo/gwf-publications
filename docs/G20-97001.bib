@article{Li-2020-SAGA:,
    title = "SAGA: Efficient and Large-Scale Detection of Near-Miss Clones with GPU Acceleration",
    author = "Li, Guanhua  and
      Wu, Yi-Jian  and
      Roy, Chanchal K.  and
      Sun, Jun  and
      Peng, Xin  and
      Zhan, Nanjie  and
      Hu, Bin  and
      Ma, Jingyi",
    journal = "2020 IEEE 27th International Conference on Software Analysis, Evolution and Reengineering (SANER)",
    year = "2020",
    publisher = "IEEE",
    url = "https://gwf-uwaterloo.github.io/gwf-publications/G20-97001",
    doi = "10.1109/saner48275.2020.9054832",
    abstract = "Clone detection on large code repository is necessary for many big code analysis tasks. The goal is to provide rich information on identical and similar code across projects. Detecting near-miss code clones on big code is challenging since it requires intensive computing and memory resources as the scale of the source code increases. In this work, we propose SAGA, an efficient suffix-array based code clone detection tool designed with sophisticated GPU optimization. SAGA not only detects Type-l and Type-2 clones but also does so for cross-project large repositories and for the most computationally expensive Type-3 clones. Meanwhile, it also works at segment granularity, which is even more challenging. It detects code clones in 100 million lines of code within 11 minutes (with recall and precision comparable to state-of-the-art approaches), which is more than 10 times faster than state-of-the-art tools. It is the only tool that efficiently detects Type-3 near-miss clones at segment granularity in large code repository (e.g., within 11 hours on 1 billion lines of code). We conduct a preliminary case study on 85,202 GitHub Java projects with 1 billion lines of code and exhibit the distribution of clones across projects. We find about 1.23 million Type-3 clone groups, containing 28 million lines of code at arbitrary segment granularity, which are only detectable with SAGA. We believe SAGA is useful in many software engineering applications such as code provenance analysis, code completion, change impact analysis, and many more.",
}
